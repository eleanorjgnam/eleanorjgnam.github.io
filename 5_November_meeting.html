<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>5 November Meeting Figures</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="5_November_meeting_files/libs/clipboard/clipboard.min.js"></script>
<script src="5_November_meeting_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="5_November_meeting_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="5_November_meeting_files/libs/quarto-html/popper.min.js"></script>
<script src="5_November_meeting_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="5_November_meeting_files/libs/quarto-html/anchor.min.js"></script>
<link href="5_November_meeting_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="5_November_meeting_files/libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="5_November_meeting_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="5_November_meeting_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="5_November_meeting_files/libs/bootstrap/bootstrap-bb462d781dde1847d9e3ccf7736099dd.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">5 November Meeting Figures</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="how-much-time-do-pre-breeders-spend-attending-colonies" class="level2">
<h2 class="anchored" data-anchor-id="how-much-time-do-pre-breeders-spend-attending-colonies">How much time do pre-breeders spend attending colonies?</h2>
<p>One natural question about pre-breeder colony attendance is how much time individuals spend attending colonies. What they do while attending colonies is restricted by how much time they have to do it, and time they spend at colonies is time they can’t spend foraging, migrating, etc. Instananeous or point-count observations of young individuals at colonies cannot answer this question, nor can data from GPS tags with long intervals between fixes.</p>
<p>My first question is how much time each of our tagged individuals spent attending any colony. We can further break that time down by colony, and ask the extent to which individuals spent more time at the colony where they were tagged.</p>
<p>In my season report for Jake and Sabina, I grouped detections for each individual into three-minute bins, filtered out bins where detections were received on only one antenna, then defined the island on which the bird was present in each bin as the island which had the greater number of antennas hit. Then, instead of turning the number of bins into a duration of time, I simply looked at the proportion of bins assigned to each island. I am unhappy with this approach for a few reasons:</p>
<ol type="1">
<li>Birds often “hang out” on one antenna in cases where I think it’s very likely that they <i> are </i> on an island. For example:</li>
</ol>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="5_November_meeting_files/figure-html/unnamed-chunk-3-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>In this case, bird #145 spends a lot of time only being heard by the south-facing antenna on Gull, and not by any other antenna. I think it’s likely that the bird was, during those periods, close enough to the island to “count”, but may have been low to the ground or otherwise in a low-detection area. In my old method, those periods where the bird was only on the south-facing antenna would have been dropped from the bird’s total attendance time. This doesn’t really make sense, because even if the bird is on the water instead of on the island, it is still spending that time in the area, and not foraging or doing anything else.</p>
<ol start="2" type="1">
<li><p>Birds often go “missing” for several minutes while attending the colonies, when they are obviously still in the area, because they come right back. For example:</p></li>
<li><p>Assigning birds to island by the receiver which had the most antennas represented might overlook cases where a detection on one antenna is very strong, but the bird is still in (weakly) range of multiple antennas from another island. I don’t think this has ever happened, but it is possible.</p></li>
</ol>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="5_November_meeting_files/figure-html/unnamed-chunk-4-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>In this case, bird #177 is “missing” between ~03:00 and 03:15, so in my prior method those bins would have been excluded from calculating its total attendance time. Again, the immediate reappearance of the bird makes me think that those “missing” minutes should still be counted, because the bird is clearly in the area during that time. Perhaps individuals briefly go out to sea, or go into burrows for a few minutes, or just fly into gullies or behind rocks and so disappear from the receiver. But again, this is clearly time spent prospecting rather than foraging, etc.</p>
<p>My new strategy is to group detections into “segments,” where the segment number changes when 1) the island that the bird is on changes or 2) the night-of date changes. So a bird that visited Gull over two separate nights would have two segments, and a bird that visited Gull, then Great, then Gull again would have three segments. I have grouped detections into two-minute bins, then assigned each bin to an island based on which station received the strongest mean detections within that bin (this is a mean of a mean; the mean power for each individual antenna is taken for each bin, then those means are averaged for each island). The segment length is then calculated by subtracting the earliest time in each segment from the latest time.</p>
<p>In the case where a segment is represented by only one bin, I set the segment length to 60 seconds (one scan cycle). A more conservative approach for one-bin segments might be to assign their length based on the number of detections in the bin; for example, if a bird was detected 5 times in a two-minute segment, the minimum time it could have been present would be 5 * 7.5 = 37.5 seconds, based on the burst interval between detections.</p>
<p>This code chunk loops through each tag ID and groups detections into segments based on changes to nightdate or island. I have only included birds that came back to visit a colony at least once after being tagged:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>visit_segments_loop <span class="ot">&lt;-</span> <span class="fu">data.frame</span>()</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>visitors <span class="ot">&lt;-</span> prospecting_detections <span class="sc">%&gt;%</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(nightdate <span class="sc">!=</span> capture_nightdate) <span class="sc">%&gt;%</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">group_by</span>(tag_id) <span class="sc">%&gt;%</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">count</span>() <span class="sc">%&gt;%</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  dplyr<span class="sc">::</span><span class="fu">select</span>(tag_id)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>visitors <span class="ot">&lt;-</span> <span class="fu">as.list</span>(visitors<span class="sc">$</span>tag_id)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> visitors) {</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>groups <span class="ot">=</span> <span class="fu">list</span>(<span class="dv">1</span>)</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>counter <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>df <span class="ot">&lt;-</span> prospecting_detections <span class="sc">%&gt;%</span> </span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(tag_id <span class="sc">==</span> i) <span class="sc">%&gt;%</span> </span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>  <span class="co">#filter(nightdate != capture_nightdate) %&gt;% </span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">bin =</span> <span class="fu">binner</span>(datetime, <span class="st">"2 mins"</span>)) <span class="sc">%&gt;%</span> </span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>  <span class="fu">group_by</span>(tag_id, bin, island, direction, capture_nightdate) <span class="sc">%&gt;%</span> </span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>  <span class="fu">summarize</span>(<span class="at">mean_power =</span> <span class="fu">mean</span>(power), <span class="at">n_detections =</span> <span class="fu">n</span>()) <span class="sc">%&gt;%</span> </span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>  <span class="fu">group_by</span>(tag_id, bin, island, capture_nightdate) <span class="sc">%&gt;%</span> </span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>  <span class="fu">summarize</span>(<span class="at">mean_power_across =</span> <span class="fu">mean</span>(mean_power), <span class="at">n_detections =</span> <span class="fu">sum</span>(n_detections)) <span class="sc">%&gt;%</span> </span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>  <span class="fu">group_by</span>(tag_id, bin) <span class="sc">%&gt;%</span> </span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>  <span class="fu">slice</span>(<span class="fu">which.max</span>(mean_power_across)) <span class="sc">%&gt;%</span> </span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">nightdate =</span> <span class="fu">nightdater</span>(bin))</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (n <span class="cf">in</span> <span class="dv">2</span><span class="sc">:</span><span class="fu">length</span>(df<span class="sc">$</span>tag_id)) {</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (df<span class="sc">$</span>island[n] <span class="sc">==</span> df<span class="sc">$</span>island[n<span class="dv">-1</span>] <span class="sc">&amp;</span> <span class="fu">as.character</span>(df<span class="sc">$</span>nightdate[n]) <span class="sc">==</span> <span class="fu">as.character</span>(df<span class="sc">$</span>nightdate[n<span class="dv">-1</span>])) {</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>      groups <span class="ot">&lt;-</span> <span class="fu">append</span>(groups,counter)</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>     <span class="co"># print("same")</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>     } <span class="cf">else</span> {</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>      counter <span class="ot">=</span> counter <span class="sc">+</span> <span class="dv">1</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>      groups <span class="ot">&lt;-</span> <span class="fu">append</span>(groups,counter)</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>      <span class="co">#print("dif")</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>groups <span class="ot">&lt;-</span> <span class="fu">as.data.frame</span>(groups) </span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>groups <span class="ot">&lt;-</span> groups <span class="sc">%&gt;%</span> </span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pivot_longer</span>(<span class="fu">everything</span>())</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>df <span class="ot">&lt;-</span> <span class="fu">cbind</span>(df, groups<span class="sc">$</span>value) <span class="sc">%&gt;%</span> </span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>  <span class="fu">rename</span>(<span class="at">segment =</span> <span class="st">`</span><span class="at">...8</span><span class="st">`</span>)</span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>visit_segments_loop <span class="ot">&lt;-</span> <span class="fu">rbind</span>(visit_segments_loop, df)</span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>By adding together the segment lengths for each bird, we can more accurately quantify the amount of time that each bird spent attending any colony:</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="5_November_meeting_files/figure-html/unnamed-chunk-6-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>We can also break attendance time down by colony, and look at how attendance time varied based on island of capture. For each bird:</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="5_November_meeting_files/figure-html/unnamed-chunk-7-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>We can also look at the total amount of time spent at each colony by all birds, grouped together by where they were tagged:</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="5_November_meeting_files/figure-html/unnamed-chunk-8-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="5_November_meeting_files/figure-html/unnamed-chunk-8-2.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>And at the distribution of attendance time birds spent at each island, grouped by where they were tagged:</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="5_November_meeting_files/figure-html/unnamed-chunk-9-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>These figures all capture essentially the same pattern: Birds are quite variable in the amount of time they spent attending colonies (and this sample only includes birds that visited at least once after being tagged), and show a general preference for the colony where they were tagged, though some individuals are exceptions. I am trying to decide what the best way to actually test for colony preference might be. Another next step would be to divide the total amount of time each bird spent at the colonies by the length of individual colony visits, to get a sense of how much they “focus” their attention on one colony or another, and to get a sense of the distribution of individual visit lengths. I could also incorporate light data here, and look at the length of island visits relative to the amount of darkness available.</p>
<p>Another way of looking at total colony attendance time is to ask how many nights each bird spent attending colonies relative to the number of nights we could have detected them. A bird that spends every possible night at a colony is having a different experience, especially relative to foraging opportunity, than one that spends one night in seven at a colony. First, I calculated each bird’s detectable period as the period between its last detection and the night it was tagged. This is the same as how I’ve calculated tag retention. Then, I counted the number of unique nights on which the bird was present at any colony. Again, this sample only includes birds that visited the colonies at least once after being tagged.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="5_November_meeting_files/figure-html/unnamed-chunk-10-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>A couple of birds were detected only once, on the night after they were tagged. The distribution of visitation rates looks like this:</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="5_November_meeting_files/figure-html/unnamed-chunk-11-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>It would be nice to find a figure that weights these proportions by the number of detectable nights, because spending two nights in a row at the colony, then leaving forever, is a different time cost than spending 19 nights out of 38 at a colony over more than a month. It is clear that, for some individuals, colony attendance represents a substantial use of time and frequently takes them away from the foraging grounds.</p>
</section>
<section id="factors-affecting-likelihood-of-returning-at-all" class="level2">
<h2 class="anchored" data-anchor-id="factors-affecting-likelihood-of-returning-at-all">Factors Affecting Likelihood of Returning At All</h2>
<p>I am interested in whether we can detect any factors that might predict whether a bird was likely to return to the colonies after being tagged. I am interested in the effect of tagging date, moon age at time of tagging (another way to do this would be to look at average moon illumination in the week or two weeks after tagging), capture location, and the bird’s body mass : wing chord ratio. Eventually I will want to include sex in this model.</p>
<p>Here, I am setting up whether each bird returned to the colonies at all as a binary (1 for returned, 0 for never returned) and running a GLM with a binomial distribution.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>bd1 <span class="ot">&lt;-</span> banding_data <span class="sc">%&gt;%</span> </span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(age_class <span class="sc">==</span> <span class="st">"AHY"</span>) <span class="sc">%&gt;%</span> </span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">returned =</span> <span class="fu">ifelse</span>(tag_id <span class="sc">%in%</span> visitors, <span class="dv">1</span>, <span class="dv">0</span>)) <span class="sc">%&gt;%</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">capture_nightdate =</span> <span class="fu">nightdater</span>(end_datetime)) <span class="sc">%&gt;%</span> </span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">capture_moon =</span> <span class="fu">moon.info</span>(capture_nightdate)) <span class="sc">%&gt;%</span> </span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">size_ratio =</span> weight <span class="sc">/</span> wing_chord)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>glm1 <span class="ot">&lt;-</span> <span class="fu">glm</span>(<span class="at">data =</span> bd1, returned <span class="sc">~</span> capture_nightdate <span class="sc">+</span> size_ratio <span class="sc">+</span> capture_moon <span class="sc">+</span> location, <span class="at">family =</span> <span class="fu">binomial</span>(<span class="at">link =</span> <span class="st">"logit"</span>))</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(glm1)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="5_November_meeting_files/figure-html/unnamed-chunk-12-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="5_November_meeting_files/figure-html/unnamed-chunk-12-2.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="5_November_meeting_files/figure-html/unnamed-chunk-12-3.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="5_November_meeting_files/figure-html/unnamed-chunk-12-4.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>The leverage plot and Q-Q look pretty good. Everything else is strange because the response variable is binomial.</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>
Call:
glm(formula = returned ~ capture_nightdate + size_ratio + capture_moon + 
    location, family = binomial(link = "logit"), data = bd1)

Coefficients:
                      Estimate Std. Error z value Pr(&gt;|z|)  
(Intercept)          1.753e+03  8.098e+02   2.164   0.0304 *
capture_nightdate   -8.604e-02  3.978e-02  -2.163   0.0305 *
size_ratio          -2.889e+01  2.205e+01  -1.311   0.1900  
capture_moon         1.741e-03  1.434e-02   0.121   0.9034  
locationGreat       -3.967e-01  1.095e+00  -0.362   0.7172  
locationGull        -4.257e-01  9.466e-01  -0.450   0.6529  
locationMiddle Lawn -1.861e+01  1.960e+03  -0.009   0.9924  
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

(Dispersion parameter for binomial family taken to be 1)

    Null deviance: 72.010  on 51  degrees of freedom
Residual deviance: 60.716  on 45  degrees of freedom
AIC: 74.716

Number of Fisher Scoring iterations: 16</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Analysis of Deviance Table

Model: binomial, link: logit

Response: returned

Terms added sequentially (first to last)

                  Df Deviance Resid. Df Resid. Dev Pr(&gt;Chi)  
NULL                                 51     72.010           
capture_nightdate  1   1.0880        50     70.922  0.29693  
size_ratio         1   2.4686        49     68.454  0.11614  
capture_moon       1   0.3572        48     68.097  0.55004  
location           3   7.3806        45     60.716  0.06071 .
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Call:
   aov(formula = glm1)

Terms:
                capture_nightdate size_ratio capture_moon  location Residuals
Sum of Squares           0.269903   0.596197     0.085421  1.415046 10.614202
Deg. of Freedom                 1          1            1         3        45

Residual standard error: 0.4856657
Estimated effects may be unbalanced</code></pre>
</div>
</div>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="5_November_meeting_files/figure-html/unnamed-chunk-14-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="5_November_meeting_files/figure-html/unnamed-chunk-14-2.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="5_November_meeting_files/figure-html/unnamed-chunk-14-3.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Night of capture is the only factor to pass a significance threshold of 0.05 in the GLM. For individuals that returned at least once, we can run a GLM with the same covariates to look at their effect on the number of visits (which ranges from 1 to 19). We could also include the birds that never returned at all with an n of 0, but I think we would want to use a zero-weighted or hurdle model in that case.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>n_visits <span class="ot">&lt;-</span> prospecting_detections <span class="sc">%&gt;%</span> </span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(tag_id <span class="sc">%in%</span> visitors) <span class="sc">%&gt;%</span> </span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(nightdate <span class="sc">!=</span> capture_nightdate) <span class="sc">%&gt;%</span> </span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">group_by</span>(tag_id) <span class="sc">%&gt;%</span> </span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">summarize</span>(<span class="at">n_visits =</span> <span class="fu">length</span>(<span class="fu">unique</span>(nightdate)))</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>bd2 <span class="ot">&lt;-</span> <span class="fu">left_join</span>(bd1, n_visits, <span class="at">by =</span> <span class="st">"tag_id"</span>)</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>bd2 <span class="ot">&lt;-</span> bd2 <span class="sc">%&gt;%</span> </span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(<span class="sc">!</span><span class="fu">is.na</span>(n_visits))</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>glm2 <span class="ot">&lt;-</span> <span class="fu">glm</span>(<span class="at">data =</span> bd2, n_visits <span class="sc">~</span> capture_nightdate <span class="sc">+</span> size_ratio <span class="sc">+</span> capture_moon <span class="sc">+</span> location, <span class="at">family =</span> <span class="fu">gaussian</span>(<span class="at">link =</span> <span class="st">"identity"</span>))</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(glm2)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="5_November_meeting_files/figure-html/unnamed-chunk-15-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="5_November_meeting_files/figure-html/unnamed-chunk-15-2.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="5_November_meeting_files/figure-html/unnamed-chunk-15-3.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="5_November_meeting_files/figure-html/unnamed-chunk-15-4.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">anova</span>(glm2)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Analysis of Deviance Table

Model: gaussian, link: identity

Response: n_visits

Terms added sequentially (first to last)

                  Df Deviance Resid. Df Resid. Dev      F  Pr(&gt;F)  
NULL                                 24     366.56                 
capture_nightdate  1   84.562        23     282.00 6.9197 0.01647 *
size_ratio         1   26.642        22     255.36 2.1801 0.15619  
capture_moon       1    4.799        21     250.56 0.3927 0.53835  
location           2   18.370        19     232.19 0.7516 0.48512  
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</code></pre>
</div>
</div>
<p>In this case, night of capture is again significant.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="5_November_meeting_files/figure-html/unnamed-chunk-16-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>I think that relationship would cease to be significant if tag #145 (19 visits) was removed from the sample. Another thing that may skew these results is that all our Baccalieu tags were deployed on the same night, which means that 17 July is overrepresented as a tagging date, and that any influence of phenology on the Baccalieu birds’ chance of returning would be obscured.</p>
<p>Some next steps might be to look at light and weather in regards to when pre-breeders attend colonies (are some nights detectably more appealing to them?) and the time they spend at colonies per night. I am also trying to think of some good ways to summarize and visualize the number and frequency of inter-colony movements.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>